[
  {
    "objectID": "resources/catalog.html",
    "href": "resources/catalog.html",
    "title": "A Catalog of APIs",
    "section": "",
    "text": "This is a non-exhaustive list of APIs that can be used to retrieve data from cultural institutions, and other sources, that can be used for research, teaching, or event to build or integrate with applications.",
    "crumbs": [
      "A Catalog of APIs"
    ]
  },
  {
    "objectID": "resources/catalog.html#us-based-apis",
    "href": "resources/catalog.html#us-based-apis",
    "title": "A Catalog of APIs",
    "section": "US Based APIs",
    "text": "US Based APIs\n\n\n\nAPI\nVersion\nDescription\nLink to Documentation\nRequires Authentication\nStatus of Documentation\n\n\n\n\nInternet Archive\nN/A\nAPI for searching and retrieving data from public collections from the Internet Archive\nIA Tools and APIs\nYes\nWell documented with examples and code snippets\n\n\nLibrary of Congress\nN/A\nProvides structured data about Library of Congress collections\nAPIs for LoC.gov\nNo\nWell documented. Some collections have their own documentation. See Additional APIs\n\n\nGetty Museum\nN/A\nAPI designed for tasks like getting records, tracking changes, and querying the collection\nGetty API Documentation\nNo\n“Work in progress”\n\n\nMetropolitan Museum of Art\nv1\nProvides access to Open Access data and public domain high-resolution images\nThe Met Collection API\nNo\nWell documented with examples and code snippets\n\n\nArt Institute of Chicago\nv1\nREST-style service to explore and integrate the museum’s public data\nArt Institute of Chicago API\nNo\nWell documented with examples and code snippets\n\n\nHarvard Art Museums\nN/A\nREST-style service for integrating museum collections in projects\nHarvard Art Museums API\nYes\nDetailed and well-documented. See GitHub Docs\n\n\nThe Cleveland Museum of Art\n4.0.0\nProvides access to the museum’s collection data in JSON format\nCleveland Museum of Art API\nNo\nWell documented but not very user-friendly\n\n\nSmithsonian Institution\nN/A\nOpen access to Smithsonian collections and research datasets\nSmithsonian API\nNo\nComprehensive documentation with examples\n\n\nHathiTrust\nN/A\nAPI for accessing and managing HathiTrust collections and data\nHathiTrust Data API\nYes\nLimited and somewhat outdated documentation\n\n\nWalters Art Museum Collections\nN/A\nAccess to Walters Art Museum’s public data and metadata\nWalters API\nNo\nLimited documentation available on GitHub\n\n\nNational Archives Catalog\nv2.0\nAccess to the National Archives collection metadata\nNational Archives API\nNo\nWell documented with examples\n\n\nThe New York Times Archive\nv3\nProvides access to NYT articles, archives, and multimedia\nNYT APIs\nYes\nComprehensive documentation with examples\n\n\nDigital Public Library of America\nN/A\nProvides access to metadata and content from partner libraries\nDPLA API Codex\nYes\nDetailed documentation available",
    "crumbs": [
      "A Catalog of APIs"
    ]
  },
  {
    "objectID": "resources/catalog.html#non-us-apis",
    "href": "resources/catalog.html#non-us-apis",
    "title": "A Catalog of APIs",
    "section": "Non-US APIs",
    "text": "Non-US APIs\n\n\n\n\n\n\nNote\n\n\n\nPolicies for using APIs from non-US institutions may be different from those in the US. It is important to check the API documentation for each institution to be aware of usage limits and other restrictions.\n\n\n\n\n\nAPI\nVersion\nDescription\nLink to Documentation\nRequires Authentication\nStatus of Documentation\n\n\n\n\nEuropeana\nv2.0\nAPI to search and retrieve European cultural heritage metadata\nEuropeana API\nYes\nComprehensive documentation with code examples\n\n\nRijksmuseum\nN/A\nProvides access to Rijksmuseum collection data and images\nRijksmuseum API\nYes\nModerately documented with examples\n\n\nV&A Collections\nN/A\nAPI for accessing the Victoria and Albert Museum’s collection data and images\nV&A API\nYes\nWell-documented with examples\n\n\nScience Museum Collections\nN/A\nAPI for accessing the Science Museum’s collection data and images\nScience Museum API\nYes\nWell documented but not very user-friendly",
    "crumbs": [
      "A Catalog of APIs"
    ]
  },
  {
    "objectID": "chapters/endpoints.html",
    "href": "chapters/endpoints.html",
    "title": "Endpoints",
    "section": "",
    "text": "In the terminology of APIs, an endpoint is a URL that specifies the location of a resource on a server. As we saw with the cat API, most of the time you can access the data from an endpoint without requiring any particular software besides a web browser.\nHowever, an API doesn’t just retrieve data, it could also create, update, or delete data. For that reason, we could say that an endpoint is a specific type of URL that allows you to perform a specific action on a resource.\nThen, let’s break the pieces of an endpoint into four parts:",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/endpoints.html#the-protocol",
    "href": "chapters/endpoints.html#the-protocol",
    "title": "Endpoints",
    "section": "The protocol",
    "text": "The protocol\nThe protocol is the first part of an endpoint, specifying whether access to the resource is done through HTTP or HTTPS. In simple terms, HTTP is the same protocol used by the web browser to retrieve web pages. The “S” in HTTPS stands for “secure” and it means that the communication between the client and the server is encrypted.\n\n\n\n\n\n\nNote\n\n\n\nCurrently, HTTPS is the de facto standard for APIs, due to enhanced security.",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/endpoints.html#the-domain",
    "href": "chapters/endpoints.html#the-domain",
    "title": "Endpoints",
    "section": "The domain",
    "text": "The domain\nThe second part of an endpoint is the domain name. This means the unique name of the host that provides the resource. In our example, the domain of the cat API is api.thecatapi.com.\n\n\n\n\n\n\nNote\n\n\n\nThe domain name of the API is not necessarily the same as the name of the main website of the API provider. For instance, the domain name of the cat API is api.thecatapi.com, but the main website of the cat API is thecatapi.com.",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/endpoints.html#the-path",
    "href": "chapters/endpoints.html#the-path",
    "title": "Endpoints",
    "section": "The path",
    "text": "The path\nThe third part of an endpoint is the path. This piece of the endpoint specifies the resource we want to access. This could be a specific set of data, for instance, a list of cat breeds, but it could also be an action to be performed, for instance, searching. The path can also specify the version of the API that is being used, for instance, “v1” or “v2”.\nIn the cat API, the path can be something like /v1/breeds.\nSome endpoints can include a resource identifier to retrieve a specific resource, for instance, the path /v1/breeds/ gives as response a list of all cat breeds, and it’s possible to retrieve a specific breed, let’s say “Korat”, by adding the identifier /kora to the path, so the full path would be /v1/breeds/kora.",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/endpoints.html#the-query-parameters",
    "href": "chapters/endpoints.html#the-query-parameters",
    "title": "Endpoints",
    "section": "The query parameters",
    "text": "The query parameters\nAn endpoint can retrieve lists of data and individual items. It can also perform actions, for instance, searching. The query parameters are the part of endpoints that allows us to explore the data available in the API. This can include multiple parts used to specify the search. Let’s explore this with more detail.\nThe Cat API has an endpoint to search for cat images. The path of this endpoint is /v1/images/search. If we do a request to this endpoint we will get a random cat image. However, the developers have included a set of parameters that can delimit the search like the size of the image, the type of the image, the format of the response, if the image has a breed, etc. In that case, instead of just having a random cat image, we can retrieve a list of cat images with a size, media type, and with a specific limit. Then, the part of the endpoint will be like this:\nsearch?size=small&mime_types=gif&limit=10\nNote that the query parameters are separated from the path by a question mark (?) and they are separated by ampersands (&). Order of the parameters is not important, but using the correct name of the parameter is crucial.",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/endpoints.html#the-full-endpoint",
    "href": "chapters/endpoints.html#the-full-endpoint",
    "title": "Endpoints",
    "section": "The full endpoint",
    "text": "The full endpoint\nNow, having all the parts of an endpoint, we can write the full endpoint as follows:\n\nThis can be read as follows: “I want to retrieve 10 cat gif images with a small size”.\nWith this result:\n\n\nCode\ncats = {\n  try {\n    return await FileAttachment(\"../_data/cats.json\").json();\n  } catch (e) {\n    console.error(\"Error loading cats data. This is normal if you're running the book locally.\", e);\n    return await FileAttachment(\"../_dev/cats-fallback.json\").json()\n  }\n}\n\nviewof carousel = {\n  const container = html`\n    &lt;div class=\"carousel-container\"&gt;\n      &lt;div class=\"carousel-wrapper\"&gt;&lt;/div&gt;\n      &lt;button class=\"carousel-button prev\"&gt;←&lt;/button&gt;\n      &lt;button class=\"carousel-button next\"&gt;→&lt;/button&gt;\n    &lt;/div&gt;\n  `;\n  \n  const wrapper = container.querySelector('.carousel-wrapper');\n  \n  cats.forEach(cat =&gt; {\n    const img = document.createElement('img');\n    img.src = cat.url;\n    img.alt = 'Cat image';\n    wrapper.appendChild(img);\n  });\n\n  let currentIndex = 0;\n  const totalImages = cats.length;\n  \n  function updateCarousel() {\n    wrapper.style.transform = `translateX(-${currentIndex * 100}%)`;\n  }\n\n  container.querySelector('.next').addEventListener('click', () =&gt; {\n    currentIndex = (currentIndex + 1) % totalImages;\n    updateCarousel();\n  });\n\n  container.querySelector('.prev').addEventListener('click', () =&gt; {\n    currentIndex = (currentIndex - 1 + totalImages) % totalImages;\n    updateCarousel();\n  });\n  \n  return container;\n}",
    "crumbs": [
      "Interacting with APIs",
      "Endpoints"
    ]
  },
  {
    "objectID": "chapters/interact-apis.html",
    "href": "chapters/interact-apis.html",
    "title": "Interacting with APIs",
    "section": "",
    "text": "Now that we understand what an API endpoint is, let’s try interacting with the Cat API directly. Enter an endpoint path below (like /v1/images/search?limit=1) to see the API response.\nTry these examples:\n\n/v1/images/search?limit=1 - Get one random cat image\n/v1/images/search?mime_types=gif - Get a random cat GIF\n/v1/breeds - Get a list of cat breeds\n/v1/breeds/siam - Get information about Siamese cats\n\n\n\n\n\n\n\nNote\n\n\n\nThe response will be shown in JSON format, which is a common data format used by APIs. JSON (JavaScript Object Notation) is a lightweight data-interchange format that is easy for humans to read and write and easy for machines to parse and generate.\n\n\n\n\nCode\nviewof method = Inputs.select([\"GET\"], {\n  label: \"HTTP Method\",\n  attributes: {\n    class: \"form-select mb-3\"\n  }\n})\n\nviewof endpoint = Inputs.text({\n  label: \"Endpoint path\", \n  placeholder: \"/v1/images/search?limit=1\",\n  value: \"/v1/images/search?limit=1\",\n  attributes: {\n    class: \"form-control mb-3\"\n  }\n})\n\n// Function to make the API request\nasync function fetchFromApi(method, path) {\n  const baseUrl = \"https://api.thecatapi.com\";\n  try {\n    const response = await fetch(`${baseUrl}${path}`);\n    const status = {\n        code: response.status,\n        ok: response.ok,\n        text: response.statusText\n    };\n    if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    const data = await response.json();\n    return { data, status };\n  } catch (error) {\n    return {\n        data: { \"Message\": `Error: ${error.message}` },\n        status: {\n            code: 400,\n            ok: false,\n            text: \"Bad Request\"\n        }\n    };\n  }\n}\n\nresponse = {\n  const result = await fetchFromApi(method, endpoint);\n  return result;\n}\n\nviewof prettyResponse = {\n    let content;\n\n    if (response.data.Message) {\n        content = html`&lt;div class=\"alert alert-warning m-0\"&gt;${response.data.Message}&lt;/div&gt;`;\n    } else {\n        content = html`&lt;pre class=\"card-body m-0\" style=\"background-color: #f8f9fa; max-height: 400px; overflow-y: auto;\"&gt;${JSON.stringify(response.data, null, 2)}&lt;/pre&gt;`;\n    }\n\n    const badgeClass = response.status.ok ? \"bg-success\" : \"bg-danger\";\n\n  const container = html`&lt;div class=\"card\"&gt;\n    &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n      &lt;span&gt;Response&lt;/span&gt;\n      &lt;span class=\"badge ${badgeClass}\"&gt;${response.status.code} ${response.status.text}&lt;/span&gt;\n    &lt;/div&gt;\n    ${content}\n  &lt;/div&gt;`;\n  return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn fact, with the same structure, we can interact with multiple APIs. Let’s try interacting with The Metropolitan Museum of Art Collection API to get the a list of objects ids from the collection.\n\n\nCode\nviewof methodParts = Inputs.select([\"GET\"], {\n    label: \"HTTP Method\",\n    attributes: {\n        class: \"form-select mb-3\"\n    }\n})\n\nviewof domain = Inputs.text({\n  label: \"Domain\",\n  placeholder: \"collectionapi.metmuseum.org\",\n  value: \"collectionapi.metmuseum.org\",\n  attributes: {\n    class: \"form-control mb-3\"\n  }\n})\n\nviewof path = Inputs.text({\n    label: \"Path\",\n    placeholder: \"/public/collection/v1/search\",\n    value: \"/public/collection/v1/search\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\nviewof query = Inputs.text({\n    label: \"Query parameters\",\n    placeholder: \"?q=cat\",\n    value: \"q=cat\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\nasync function fetchFromApiParts(method, domain, path, query) {\n    try {\n        const baseUrl = `https://${domain}`;\n        const url = `${baseUrl}${path}?${query}`;\n        const response = await fetch(url);\n        const status = {\n            code: response.status,\n            ok: response.ok,\n            text: response.statusText\n        };\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return { data, status };\n    } catch (error) {\n        return {\n            data: { \"Message\": `Error: ${error.message}` },\n            status: {\n                code: 400,\n                ok: false,\n                text: \"Bad Request\"\n            }\n        };\n    }\n}\n\nresponseParts = {\n    const result = await fetchFromApiParts(methodParts, domain, path, query);\n    return result;\n}\n\nviewof prettyResponseParts = {\n    let content;\n    if (responseParts.data.Message) {\n        content = html`&lt;div class=\"alert alert-warning m-0\"&gt;${responseParts.data.Message}&lt;/div&gt;`;\n    } else {\n        content = html`&lt;pre class=\"card-body m-0\" style=\"background-color: #f8f9fa; max-height: 400px; overflow-y: auto;\"&gt;${JSON.stringify(responseParts.data, null, 2)}&lt;/pre&gt;`;\n    }\n    \n    const badgeClass = responseParts.status.ok ? \"bg-success\" : \"bg-danger\";\n    \n    const container = html`&lt;div class=\"card\"&gt;\n        &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n            &lt;span&gt;Response&lt;/span&gt;\n            &lt;span class=\"badge ${badgeClass}\"&gt;${responseParts.status.code} ${responseParts.status.text}&lt;/span&gt;\n        &lt;/div&gt;\n        ${content}\n    &lt;/div&gt;`;\n    return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNow, take any ID from the result and use it to get the object details from the API.\n\n\nCode\nviewof methodDetails = Inputs.select([\"GET\"], {\n    label: \"HTTP Method\",\n    attributes: {\n        class: \"form-select mb-3\"\n    }\n})\n\nviewof domainDetails = Inputs.text({\n    label: \"Domain\",\n    placeholder: \"collectionapi.metmuseum.org\",\n    value: \"collectionapi.metmuseum.org\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\nviewof pathDetails = Inputs.text({\n    label: \"Path\",\n    placeholder: \"/public/collection/v1/objects/\",\n    value: \"/public/collection/v1/objects/\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\nviewof parameterDetails = Inputs.text({\n    label: \"Parameter\",\n    placeholder: \"Write the object id here\",\n    value: \"570744\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\nasync function fetchFromApiDetails(method, domain, path, parameter) {\n    try {\n        const baseUrl = `https://${domain}`;\n        const url = `${baseUrl}${path}${parameter}`;\n        const response = await fetch(url);\n        const status = {\n            code: response.status,\n            ok: response.ok,\n            text: response.statusText\n        };\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n        const data = await response.json();\n        return { data, status };\n    } catch (error) {\n        return { error: error.message };\n    }\n}\n\nresponseDetails = {\n    const result = await fetchFromApiDetails(methodDetails, domainDetails, pathDetails, parameterDetails);\n    return result;\n}\n\nviewof prettyResponseDetailsContainer = {\n    let content;\n    if (responseDetails.data.Message) {\n        content = html`&lt;div class=\"alert alert-warning m-0\"&gt;${responseDetails.data.Message}&lt;/div&gt;`;\n    } else {\n        content = html`&lt;pre class=\"card-body m-0\" style=\"background-color: #f8f9fa; max-height: 400px; overflow-y: auto;\"&gt;${JSON.stringify(responseDetails.data, null, 2)}&lt;/pre&gt;`;\n    }\n\n    const badgeClass = responseDetails.status.ok ? \"bg-success\" : \"bg-danger\";\n\n    const container = html`&lt;div class=\"card\"&gt;\n        &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n            &lt;span&gt;Response&lt;/span&gt;\n            &lt;span class=\"badge ${badgeClass}\"&gt;${responseDetails.status.code} ${responseDetails.status.text}&lt;/span&gt;\n        &lt;/div&gt;\n        ${content}\n    &lt;/div&gt;`;\n    return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAnd that allows us to retrieve, for instance, the image of the object, that is stored in the primaryImage field.\n\n\nCode\nviewof primaryImage = {\n    const primaryImage = responseDetails.status.ok ? responseDetails.data.primaryImageSmall : \"https://placehold.co/600x400\";\n    if (primaryImage) {\n        const img = html`&lt;img src=\"${primaryImage}\" alt=\"Primary Image\"&gt;`;\n        return img;\n    } else {\n        return html`&lt;img src=\"https://placehold.co/600x400\" alt=\"Placeholder\"&gt;`;\n    }\n\n}\n\n\n\n\n\n\n\nNice! Now, let’s do an exercise to practice what we have learned.",
    "crumbs": [
      "Interacting with APIs",
      "Interacting with APIs"
    ]
  },
  {
    "objectID": "chapters/collecting-data-for-analysis.html",
    "href": "chapters/collecting-data-for-analysis.html",
    "title": "Collecting Data for Analysis",
    "section": "",
    "text": "During the previous chapters, we learned how to interact with APIs to retrieve data. We also practiced retrieving the total number of objects that contain a specific term in a particular department of the Metropolitan Museum of Art.\nIn this chapter, we will take the next step: collecting and analyzing data using the Metropolitan Museum of Art API. Specifically, we will explore the question: What thematic areas can we identify from the terms associated with objects in the Medieval Art collection?\nBy analyzing how pairs of terms co-occur, we aim to uncover thematic areas and explore whether these topics reveal insights about Medieval Art — at least from the perspective of the Metropolitan Museum of Art’s metadata.\nThis chapter will show how data-driven analysis can provide a fresh lens to interpret cultural artifacts and examine the stories embedded within museum collections.",
    "crumbs": [
      "APIs for Data Analysis",
      "Collecting Data for Analysis"
    ]
  },
  {
    "objectID": "chapters/collecting-data-for-analysis.html#preparing-the-data-collection-and-preservation",
    "href": "chapters/collecting-data-for-analysis.html#preparing-the-data-collection-and-preservation",
    "title": "Collecting Data for Analysis",
    "section": "Preparing the data collection and preservation",
    "text": "Preparing the data collection and preservation\nBefore starting to collect data, it’s important to think ahead and plan how the data will be collected, stored, and preserved for future use. Although this is a small project, we can follow some best practices to ensure data integrity and reproducibility.\nOur first step is to create a directory structure to store the data and file naming conventions. We will create a directory called data to store both the raw and processed data. We will also create a directory to store the code used to collect data, and a directory to store the results of the analysis. Additionally, we will create a README.md file to document the project and a LICENSE file to specify the license under which the data is made available.\nThe project directory structure would look like this:\nproject/\n├── data/\n│   ├── raw/ # Original, unprocessed data\n│   ├── processed/ # Cleaned and transformed data for analysis\n├── code/ # Scripts used for data collection and processing\n├── README.md # Project documentation\n├── LICENSE # Licensing information\nTo ensure consistency, we will use clear and descriptive names for our files. For example:\n\nraw_medieval_art_tags.csv: The original data collected from the API.\nprocessed_term_pairs.csv: The processed dataset containing term pairs with weights.\n\nVisit the project repository on GitHub to explore the full directory structure, example files, and scripts.\n\n\n\n\n\n\nAbout Data Use\n\n\n\n\n\nIt’s important to check the data source documentation to identify the terms of use and any possible restrictions. In this case, the Metropolitan Museum of Art has published the data under a Creative Commons Zero (CC0) license. This means the data is free to use and distribute without restrictions. For more details, visit the API documentation.",
    "crumbs": [
      "APIs for Data Analysis",
      "Collecting Data for Analysis"
    ]
  },
  {
    "objectID": "chapters/collecting-data-for-analysis.html#what-data-to-collect",
    "href": "chapters/collecting-data-for-analysis.html#what-data-to-collect",
    "title": "Collecting Data for Analysis",
    "section": "What data to collect?",
    "text": "What data to collect?\nBefore starting to collect data, we need to explore what data is available and how it can help answer our research question.\nThe first step is to examine a random object from the Medieval Art collection to identify useful fields for our analysis. We can use the endpoint https://collectionapi.metmuseum.org/public/collection/v1/objects?departmentIds=17 to retrieve a list of object IDs from the Medieval Art collection. Simply paste the full endpoint into your browser to see a response like this:\n\n{\n     \"total\": 7136,\n     \"objectIDs\": [\n        32830, 32831, 32832, 32833, 32834,\n        32835, 32836, 32837, 32838, 32839,\n        // ... many more IDs ...\n        818469, 818574, 831188\n        ]\n}\nOnce we have an object ID, we can use it to get detailed information about that object by appending the ID to the endpoint https://collectionapi.metmuseum.org/public/collection/v1/objects/{objectID}. For example, the object with ID 32830 gives the following detailed response:\n{\n  \"objectID\": 32830,\n  \"isHighlight\": false,\n  \"accessionNumber\": \"23.21.2\",\n  \"accessionYear\": \"1923\",\n  \"isPublicDomain\": true,\n  \"primaryImage\": \"https://images.metmuseum.org/CRDImages/md/original/DP164978.jpg\",\n  \"primaryImageSmall\": \"https://images.metmuseum.org/CRDImages/md/web-large/DP164978.jpg\",\n  \"additionalImages\": [\n    \"https://images.metmuseum.org/CRDImages/md/original/DP164979.jpg\"\n  ],\n  \"constituents\": null,\n  \"department\": \"Medieval Art\",\n  \"objectName\": \"Manuscript cutting from a Dominican antiphonary\",\n  \"title\": \"Initial P with the Martyrdom of Saint Peter Martyr\",\n  \"culture\": \"Italian\",\n  \"period\": \"\",\n  \"dynasty\": \"\",\n  \"reign\": \"\",\n  \"portfolio\": \"\",\n  \"artistRole\": \"\",\n  \"artistPrefix\": \"\",\n  \"artistDisplayName\": \"\",\n  \"artistDisplayBio\": \"\",\n  \"artistSuffix\": \"\",\n  \"artistAlphaSort\": \"\",\n  \"artistNationality\": \"\",\n  \"artistBeginDate\": \"\",\n  \"artistEndDate\": \"\",\n  \"artistGender\": \"\",\n  \"artistWikidata_URL\": \"\",\n  \"artistULAN_URL\": \"\",\n  \"objectDate\": \"second half 13th century\",\n  \"objectBeginDate\": 1350,\n  \"objectEndDate\": 1400,\n  \"medium\": \"Tempera and ink on parchment\",\n  \"dimensions\": \"3 1/8 x 2 13/16 in. (7.9 x 7.1 cm)\",\n  \"measurements\": null,\n  \"creditLine\": \"Gift of Bashford Dean, 1923\",\n  \"geographyType\": \"Made in\",\n  \"city\": \"Bologna\",\n  \"state\": \"\",\n  \"county\": \"\",\n  \"country\": \"Italy\",\n  \"region\": \"\",\n  \"subregion\": \"\",\n  \"locale\": \"\",\n  \"locus\": \"\",\n  \"excavation\": \"\",\n  \"river\": \"\",\n  \"classification\": \"Manuscripts and Illuminations\",\n  \"rightsAndReproduction\": \"\",\n  \"linkResource\": \"\",\n  \"metadataDate\": \"2024-10-03T04:53:53.567Z\",\n  \"repository\": \"Metropolitan Museum of Art, New York, NY\",\n  \"objectURL\": \"https://www.metmuseum.org/art/collection/search/32830\",\n  \"tags\": [\n    {\n      \"term\": \"Saint Peter\",\n      \"AAT_URL\": \"http://vocab.getty.edu/page/ia/901000056\",\n      \"Wikidata_URL\": \"https://www.wikidata.org/wiki/Q33923\"\n    },\n    {\n      \"term\": \"Men\",\n      \"AAT_URL\": \"http://vocab.getty.edu/page/aat/300025928\",\n      \"Wikidata_URL\": \"https://www.wikidata.org/wiki/Q8441\"\n    }\n  ],\n  \"objectWikidata_URL\": \"\",\n  \"isTimelineWork\": true,\n  \"GalleryNumber\": \"\"\n}\nBy exploring the object data, we can identify several fields of interest:\n\ntitle: Provides the name of the object.\nobjectName: Describes the type of object (e.g., Manuscript cutting).\nmedium: Indicates the materials used to create the object.\nculture: Describes the cultural origin of the object.\nobjectDate: Includes date information.\ntags: Provides controlled vocabulary terms that capture themes and concepts.\n\nFor our analysis, we will focus on the tags field, which provides a list of terms associated with the object. The tags field is particularly valuable because it uses controlled vocabularies like the Art and Architecture Thesaurus (AAT) and Wikidata, ensuring consistency across the dataset. These terms capture key themes and concepts, making them ideal for analyzing thematic areas in Medieval Art.\nDocumenting the focus of our analysis in a README.md file is a critical step in ensuring transparency and reproducibility. The README.md file provides future researchers (or your future self!) with a clear understanding of the dataset, its purpose, and how it was used. Here’s an example of how you can document this information:\nHaving identified the tags field as the focus of our analysis, we can include that information in our README.md file to document the project. This is an example of how we can include that information in the README.md file:\n\n\n\n\n\n\nMedieval Art Collection Analysis\n\n\n\nThis project aims to analyze the Medieval Art collection of the Metropolitan Museum of Art. The focus of this analysis is on the tags field, which provides a list of terms associated with each object, using controlled vocabularies like the Art and Architecture Thesaurus (AAT) and Wikidata. With that information, we aim to identify thematic areas and explore whether these topics reveal insights about Medieval Art — at least from the perspective of the Metropolitan Museum of Art’s metadata, and propose a method to analyze arbitrary terms associated with museum collections.\nLicense and right of use\nThe data provided by the Metropolitan Museum of Art is published under a Creative Commons Zero (CC0) license. This means that the data is in the public domain and can be used for any purpose without restriction. The derived data and code written for this project is published under the same license.",
    "crumbs": [
      "APIs for Data Analysis",
      "Collecting Data for Analysis"
    ]
  },
  {
    "objectID": "chapters/collecting-data-for-analysis.html#collecting-data",
    "href": "chapters/collecting-data-for-analysis.html#collecting-data",
    "title": "Collecting Data for Analysis",
    "section": "Collecting data",
    "text": "Collecting data\nNow that we have identified the tags field as the focus of our analysis, we can start collecting data. To do this, we need to extract the specific information we need and store it in a format suitable for analysis.\nTypically, this involves isolating the necessary information and storing it in a structured format like CSV (Comma-Separated Values). For our purpose, the CSV file will have two columns: objectID and tags. An example of the data is shown below:\nobjectID,terms\n462990,\"['Entombment', 'Christ', 'Virgin Mary']\"\n462991,['Women']\n462992,\"['Men', 'Cross', 'Christ']\"\n462994,['Men']\n462995,['Men']\n462997,\"['Cross', 'Christ']\"\n462998,\"['Animals', 'Birds']\"\n463015,\"['Men', 'Portraits']\"\n463023,['Deer']\n463024,['Eagles']\n463032,\"['Entombment', 'Christ']\"\n463036,\"['Illness', 'Men', 'Women']\"\n463037,\"['Kings', 'Women', 'David', 'Eve']\"\n463039,\"['Kings', 'Baptismal Fonts', 'Saints']\"\n463040,\"['Infants', 'Women', 'Baptismal Fonts']\"\n463052,['Deer']\n463081,\"['Animals', 'Cross']\"\n463083,['Human Figures']\n463084,\"['Human Figures', 'Angels']\"\nThis data was collected from the first 100 objects in the Medieval Art collection. It’s important to note that not all objects have tags, and some only have one term. Exploring the data is crucial to understanding its completeness and whether it can answer our research question.\nEven with incomplete data, we can still identify thematic areas. For example, we can extract term pairs that co-occur within the same object. For object ID 462990, the terms Entombment, Christ, and Virgin Mary co-occur, which can be represented like this:\nSource,Target\nEntombment,Christ\nEntombment,Virgin Mary\nChrist,Virgin Mary\nWhen we notice that some pairs repeat across different objects, we can add weights to these pairs. For example, the pair Men and Cross appears in both 462992 and 462997, giving it a weight of 2. The table becomes:\nSource,Target,Weight\nEntombment,Christ,1\nEntombment,Virgin Mary,1\nChrist,Virgin Mary,1\nMen,Cross,2\nMen,Christ,1\nCross,Christ,1\nUsing this small sample, we can already start drafting a simple network graph to visualize these relationships.\n\n\nCode\nlibrary(igraph)\n\nedges &lt;- data.frame(\n  Source = c(\n  \"Entombment\", \"Entombment\", \"Christ\", \"Men\", \"Men\", \"Cross\", \n  \"Animals\", \"Men\", \"Illness\", \"Illness\", \"Men\", \"Kings\", \n  \"Kings\", \"Kings\", \"Women\", \"Women\", \"David\"\n),\n  Target = c(\n  \"Christ\", \"Virgin Mary\", \"Virgin Mary\", \"Cross\", \"Christ\", \"Christ\", \n  \"Birds\", \"Portraits\", \"Men\", \"Women\", \"Women\", \"Women\", \n  \"David\", \"Eve\", \"David\", \"Eve\", \"Eve\"\n),\n  Weight = c(\n  2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n)\n\n)\n\nnetwork &lt;- graph_from_data_frame(edges, directed = FALSE)\n\nplot(\n  network,\n  vertex.size = 30,\n  vertex.label.cex = 0.8,\n  edge.width = E(network)$Weight * 2,\n  edge.color = \"gray50\",\n  vertex.color = \"lightblue\",\n  main = \"Network Graph\"\n)\n\n\n\n\n\n\n\n\n\nThis simple network graph provides a glimpse of the relationships between terms. For instance, we can see how the network is highly centered around the term “Men,” which connects with other groups associated with “Christ.” In contrast, “Women” is part of a smaller group tied to terms like “Eve,” “David,” and “Kings.” While this is just a small sample, it demonstrates how network analysis can reveal thematic patterns.\nWith this proof of concept, we’re ready to scale up to the entire Medieval Art collection. The complete data includes term pairs from 3695 objects, resulting in 1725 unique pairs. The dataset is stored in a CSV file, which can be accessed here: Medieval Art Data - Terms Network. Below is a preview of the first 20 rows:\n\n\nCode\nterms_collection &lt;- read.csv(\"../data/terms_collection17.csv\")\nhead(terms_collection, 20)\n\n\n                  Source                     Target Weight\n1               Achilles                   Centaurs      1\n2               Achilles                     Horses      1\n3               Achilles                        Men      1\n4               Achilles                      Tents      1\n5               Achilles                 Trojan War      1\n6                   Adam                     Angels      1\n7                   Adam                     Christ      2\n8                   Adam                Crucifixion      2\n9                   Adam                        Eve      6\n10                  Adam                   Nativity      1\n11                  Adam                Virgin Mary      1\n12                  Adam                    Working      1\n13 Adoration of the Magi Adoration of the Shepherds      2\n14 Adoration of the Magi                     Angels      4\n15 Adoration of the Magi               Annunciation      5\n16 Adoration of the Magi                       Beds      1\n17 Adoration of the Magi                     Christ      8\n18 Adoration of the Magi                Crucifixion      6\n19 Adoration of the Magi                       Dogs      1\n20 Adoration of the Magi                      Jesus      6\n\n\nIn the next chapter, we’ll use this full dataset to build a comprehensive network graph, analyze its structure, and uncover thematic clusters that provide deeper insights into the Medieval Art collection.\n\n\n\n\n\n\nA Note About Automation\n\n\n\n\n\nTo collect the data for this project, we used a Python script to automate the process. This ensured accuracy and efficiency when processing thousands of objects in the Medieval Art collection. The script performs the following steps:\n\nRetrieves object IDs from the API.\nFetches tags for each object.\nGenerates term pairs and calculates weights.\nSaves the results in a CSV file for analysis.\n\nCode is available in the project repository. If you’re familiar with Python, you can experiment with it to collect data from other departments or customize it to fit your needs",
    "crumbs": [
      "APIs for Data Analysis",
      "Collecting Data for Analysis"
    ]
  },
  {
    "objectID": "chapters/what-is-an-api.html",
    "href": "chapters/what-is-an-api.html",
    "title": "What is an API?",
    "section": "",
    "text": "&lt;script&gt;\nwindow.getRandomCat = async function () {\n    \n    const response = await fetch(\"https://api.thecatapi.com/v1/images/search?size=med&mime_types=jpg&format=json&has_breeds=true&order=RANDOM&page=0&limit=1\");\n    if (!response.ok) throw new Error(\"Failed to fetch random cat.\");\n    const data = await response.json();\n\n    const cat = data[0];\n    const cat_id = cat.id;\n\n    const cat_detailed_info = await fetch(`https://api.thecatapi.com/v1/images/${cat_id}`);\n    const cat_detailed_info_json = await cat_detailed_info.json();\n\n    // Safely access items that might be undefined or empty\n    const breed = cat_detailed_info_json.breeds && cat_detailed_info_json.breeds.length &gt; 0 ? cat_detailed_info_json.breeds[0].name : \"Unknown\";\n    const description = cat_detailed_info_json.breeds && cat_detailed_info_json.breeds.length &gt; 0 ? cat_detailed_info_json.breeds[0].description : \"Unknown\";\n\n    document.getElementById(\"cat-image\").innerHTML = `\n        &lt;div class=\"card\" style=\"max-width: 300px; margin: 15px auto;\"&gt;\n            &lt;img src=\"${cat.url}\" class=\"card-img-top\" alt=\"Random Cat\"&gt;\n            &lt;div class=\"card-body\"&gt;\n                &lt;h5 class=\"card-title\"&gt;Breed: ${breed}&lt;/h5&gt;\n                &lt;p class=\"card-text\"&gt;${description}&lt;/p&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    `;\n};\n&lt;/script&gt;\n&lt;button onclick=\"getRandomCat()\" class=\"btn btn-primary\" style=\"padding: 10px 20px; font-size: 16px; display: block; margin: 0 auto;\"&gt;Click here to get a random cat :)&lt;/button&gt;\n&lt;div id=\"cat-image\" style=\"margin-top: 15px;\"&gt;&lt;/div&gt;\nAn API (Application Programming Interface) is a set of rules and protocols enabling software programs to communicate and share information. While the term is often associated with “web APIs,” it encompasses a broader concept. For instance, an API might allow a library to share its collection data with a museum or enable a weather service to provide updates to a news organization. APIs operate based on predefined rules set by developers, specifying how data can be accessed and used. While some APIs are public, most are internal, facilitating communication between systems within an organization.",
    "crumbs": [
      "What are APIs and why do they exists"
    ]
  },
  {
    "objectID": "chapters/what-is-an-api.html#using-an-api",
    "href": "chapters/what-is-an-api.html#using-an-api",
    "title": "What is an API?",
    "section": "Using an API",
    "text": "Using an API\nFor those unfamiliar with computer science, APIs can be a bit abstract, so let’s try to explain it better with this example using the The Cat API. This API allows you to get information about different cat and dog breeds, with images and descriptions. The information is not available through a public interface, so if you want to see a cat image, you must use the API.\nIn this example, let’s get the information about the Ragdoll cat breed. To do this, we require to use this API endpoint: https://api.thecatapi.com/v1/images/XFhRpYS_D.\nYou can click on that link to view the information about the cat in a format similar to this:\n\n\nCode\nasync function getCatData(catId) {\n    const url = `https://api.thecatapi.com/v1/images/${catId}`;\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);\n    const data = await response.json();\n    return data;\n}\n\ncatData = await getCatData(\"XFhRpYS_D\");\n\nviewof catDataString = {\n  const pre = html`&lt;pre style=\"background-color: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto;\"&gt;`;\n  const code = html`&lt;code style=\"color: #333;\"&gt;`;\n  \n  // Formatted JSON with syntax highlighting\n  const formatted = JSON.stringify(catData, null, 2)\n    .replace(/&/g, '&amp;')\n    .replace(/&lt;/g, '&lt;')\n    .replace(/&gt;/g, '&gt;')\n    .replace(/\"([^\"]+)\":/g, '&lt;span style=\"color: #a31515;\"&gt;\"$1\"&lt;/span&gt;:') \n    .replace(/: \"([^\"]+)\"/g, ': &lt;span style=\"color: #008000;\"&gt;\"$1\"&lt;/span&gt;')  \n    .replace(/: ([0-9]+)/g, ': &lt;span style=\"color: #0000FF;\"&gt;$1&lt;/span&gt;')  \n    .replace(/\\b(true|false|null)\\b/g, '&lt;span style=\"color: #FF0000;\"&gt;$1&lt;/span&gt;');\n    \n  code.innerHTML = formatted;\n  pre.appendChild(code);\n  return pre;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis format is called JSON, and its widely used in APIs to return data. We will see more about this format later, but for now, we can say that this output is called a response, and it contains keys and values. Keys are the names of the information we requested and values are the information we received. For instance, in this response, the url to the image of a Ragdoll cat can be found under the url key, and its value is https://cdn2.thecatapi.com/images/XFhRpYS_D.jpg.\n\n\n\nJSON syntax\n\n\nNow, what we want to do is to get the image of the Ragdoll, not just the abstract information. To do this, we have to access the values associated with each key. The url to the image is under the url key, the name of the cat is under the breeds key and the description is under the description key. With a bit of coding, we can display the image of the cat:\n\n\nCode\nfunction displayCat(data) {\n    const container = html`&lt;div class=\"card\" style=\"max-width: 300px; margin: 15px auto;\"&gt;\n        &lt;img src=\"${data.url}\" class=\"card-img-top\" alt=\"Ragdoll cat\"&gt;\n        &lt;div class=\"card-body\"&gt;\n            &lt;h5 class=\"card-title\"&gt;Breed: ${data.breeds[0].name}&lt;/h5&gt;\n            &lt;p class=\"card-text\"&gt;${data.breeds[0].description}&lt;/p&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;`;\n    return container;\n}\n\ndisplayCat(catData);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCute, isn’t it?\nWhat the API is doing, is to get the information from the server database, return it to the client in a format that can be easily parsed by a computer, and then the browser can use this information to display the cat image, or to get additional information about the cat.\n\n\n\nA simple representation of an API (click to zoom)\n\n\nWith that information, we can display the information in a more readable format, and reutilize the method to get the image of other cats, for instance, a Bengal cat:\n\n\nCode\nbengalCatData = await getCatData(\"LSaDk6OjY\");\ndisplayCat(bengalCatData);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can even get a random cat image!\n  Code \n\n\n\nClick here to get a random cat :)\n\n\n\n\n\n\nNow that we’ve seen how APIs work, let’s dive into why they’re so essential.",
    "crumbs": [
      "What are APIs and why do they exists"
    ]
  },
  {
    "objectID": "chapters/what-is-an-api.html#why-do-we-need-apis",
    "href": "chapters/what-is-an-api.html#why-do-we-need-apis",
    "title": "What is an API?",
    "section": "Why Do We Need APIs?",
    "text": "Why Do We Need APIs?\nA common question might be: why use an API instead of simply sharing the data directly?\n\nSimplifying Access to Data\nFor researchers, APIs simplify access to complex datasets. Imagine working with a public archive or a library catalog where data is stored in various relational tables. Instead of manually extracting and organizing the data, an API allows you to query for specific subsets—like texts published in a particular year or metadata about historical photographs—without worrying about the database structure.\nAn API simplifies this process by predefining these complex queries and providing endpoints to access the data you need with minimal effort. Instead of interacting directly with the database, users make requests to the API and receive only the required data in a user-friendly format, like JSON.\n\n\nEnhancing Security and Performance\nDirect access to a database can compromise its security and integrity. Opening a database to the public exposes it to risks, such as unauthorized modifications or data breaches. APIs mitigate these risks by controlling what data is accessible and to whom. For instance APIs can restrict access to specific users or IP addresses. APIs can also limit the amount of data retrieved, improving performance.\nFor collaborative research, APIs ensure secure and consistent access to data across teams and institutions. They also enhance reproducibility by allowing other researchers to replicate data retrieval processes through well-documented endpoints.\n\n\nWhy Not Share Data as a Downloadable File?\nSharing data in formats like Excel or CSV files can sometimes be a practical solution. However, this approach has significant limitations, for instance, downloadable files do not automatically update when the source data changes. Users must re-download the file every time updates are made, which can lead to outdated information. Another limitation is associated with the size of the file. For large datasets, downloading and processing the entire file can be inefficient and cumbersome.\nUltimately, whether to use an API or share data as a downloadable file depends on the project’s specific needs, balancing dynamic access with ease of use. When you need to retrieve specific data subsets or interact with the data dynamically, an API is ideal. It provides granularity and ensures users access the most up-to-date information. When users need the entire dataset for analysis or offline use, offering a downloadable file might be more appropriate.\n\n\n\n\n\n\nAPIs for bulk data retrieval\n\n\n\n\n\nAPIs are not designed for bulk data retrieval but for accessing data in a more focused and controlled way. It bridges the gap between complex databases and the users who need specific, timely information.",
    "crumbs": [
      "What are APIs and why do they exists"
    ]
  },
  {
    "objectID": "chapters/what-is-an-api.html#apis-in-research",
    "href": "chapters/what-is-an-api.html#apis-in-research",
    "title": "What is an API?",
    "section": "APIs in Research",
    "text": "APIs in Research\nIn research, APIs bridge the gap between data and analysis by automating data collection and streamlining workflows. A historian studying digitized newspapers, for instance, can use APIs to query articles that mention specific events, dates, or people. Social scientists can analyze real-time conversations and trends through APIs from platforms like X or YouTube, while environmental researchers can leverage satellite data APIs to monitor deforestation patterns. By enabling seamless integration across datasets, APIs foster interdisciplinary collaboration and empower scholars to tackle complex questions with innovative approaches.\n\n\n\n\n\n\nIn summary\n\n\n\n\n\nAPIs are not just tools for developers—they hold immense potential for researchers, too. By providing structured, dynamic access to datasets, APIs enable scholars to automate data collection, access real-time information, and integrate diverse data sources into their workflows. Whether you’re studying digital humanities, analyzing climate data, or investigating social media trends, APIs allow you to retrieve exactly the data you need, at scale and with precision. Embracing APIs as part of your research toolkit opens doors to innovative methodologies and insights that might otherwise remain out of reach.",
    "crumbs": [
      "What are APIs and why do they exists"
    ]
  },
  {
    "objectID": "chapters/exercise-calling-data.html",
    "href": "chapters/exercise-calling-data.html",
    "title": "Exercise: Calling Data from an API",
    "section": "",
    "text": "A query is basically a question, so, let’s try to answer this question: How many ‘knights’ are in the department of Medieval Art of the Metropolitan Museum of Art? To answer that question, we have to segment it into multiple parts:\n\nWhat is required to search within a specific department in the API?\nWhat endpoint do we need to use?\nWhat parameters do we need to use?\nWhat’s the previous information we need to retrieve before doing the query?\nWhat is the query we need to use?\nHow do we get the specific information we need?\n\nSeems like a lot of steps, but it’s not too complex as it might seem. Let’s start with the first step: looking at the API documentation: Metropolitan Museum of Art Collection API\nBecause the first question is about searching within a specific scope, let’s start with the search endpoint. As we can see, there is a list of paremeters, the first one is q, which is the one that helps us to search by term (like ‘knight’); and scrolling down a little, we can see the departmentId parameter, which requires a numeric (integer) identifier corresponding to the department we want to search within:\n\n\n\n\n\n\n\n\nParameter\nFormat\nNotes\n\n\n\n\nq\nSearch term e.g. sunflowers\nReturns a listing of all Object IDs for objects that contain the search query within the object’s data\n\n\ndepartmentId\nInteger\nReturns objects that are a part of a specific department. For a list of departments and department IDs, refer to our /department endpoint: https://collectionapi.metmuseum.org/public/collection/v1/departments \n\n\n\nAs you can see, documentation is the best starting point to interact with an API. With that information, we have answered not only the first question, but also what endpoint, parameters, and previous information we need to retrieve before doing the query.\nBefore proceeding with the next question, let’s get the list of departments and their IDs to select the one corresponding to the ‘Medieval Art’ department. To do that, just paste the ‘/department’ endpoint as is pointed out in the documentation (if you get lost, follow the hints ;) ).\nScroll down to see the list of departments and their departmentId. Copy the value of the departmentId for the ‘Medieval Art’ department (the number, not the name). We’ve underlined the value in the list for you.\n\n\nCode\nviewof departmentListEndpoint = Inputs.text({\n    label: \"Department list\",\n    placeholder: \"\",\n    value: \"\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n})\n\n/**\n * The purpose of this function is only to validate the endpoint\n * for students. Have this in mind if want to replicate the\n * code in other exercises.\n */\nasync function validateEndpoint(endpoint, query, params) {\n    const checks = [\n        {\n            pattern: /^https:\\/\\//,\n            message: \"URL must start with 'https://'\"\n        },\n        {\n            pattern: /collectionapi\\.metmuseum\\.org/,\n            message: \"URL must contain 'collectionapi.metmuseum.org'\"\n        },\n        {\n            pattern: /\\/public\\//,\n            message: \"Missing '/public/' in the path\"\n        },\n        {\n            pattern: /\\/collection\\//,\n            message: \"Missing '/collection/' in the path\"\n        },\n        {\n            pattern: /\\/v1\\//,\n            message: \"Missing '/v1/' in the path\"\n        }\n    ];\n\n    if (params) {\n        const paramsList = params.split(\"&\");\n        checks.push(\n            {\n                pattern: new RegExp(`${query}\\\\?`),\n                message: `URL must contain '${query}' before parameters`\n            },\n            {\n                pattern: /[?]/g,\n                message: \"Query and parameters must be separated by '?'\"\n            },\n            ...paramsList.map(param =&gt; ({\n                pattern: new RegExp(param),\n                message: `Missing parameter: ${param}`\n            }))\n        );\n    } else {\n        checks.push(\n            {\n                pattern: new RegExp(`${query}$`),\n                message: `URL must end with '${query}'`\n            }\n        )\n    }\n\n    if (/[^:]\\/\\//.test(endpoint)) {\n        return \"Invalid URL: Contains double slashes (//)\";\n    }\n\n    const segments = ['collectionapi.metmuseum.org', 'public', 'collection', 'v1', query];\n    for (let i = 0; i &lt; segments.length - 1; i++) {\n        const pattern = new RegExp(`${segments[i]}[^/]+${segments[i + 1]}`);\n        if (pattern.test(endpoint)) {\n            return `Missing slash between '${segments[i]}' and '${segments[i + 1]}'`;\n        }\n    }\n\n    const basePattern = new RegExp(`^https:\\/\\/collectionapi\\.metmuseum\\.org\\/public\\/collection\\/v1\\/${query}`);\n    if (!basePattern.test(endpoint.split('?')[0])) {\n        return `Base URL is incorrect. Should start with: https://collectionapi.metmuseum.org/public/collection/v1/${query}`;\n    }\n\n    for (const check of checks) {\n        if (!check.pattern.test(endpoint)) {\n            return check.message;\n        }\n    }\n\n    return null;\n}\n\nasync function fetchDepartmentList(endpoint) {\n    try {\n        const response = await fetch(endpoint);\n        const status = {\n            code: response.status,\n            ok: response.ok,\n            text: response.statusText\n        };\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const data = await response.json();\n        return { data, status};\n    } catch (error) {\n        return {\n            data: { \"Message\": `Error: ${error.message}` },\n            status: {\n                code: 400,\n                ok: false,\n                text: \"Bad Request\"\n            }\n        };\n    }\n}\n\ndepartmentList = {\n    if (departmentListEndpoint) {\n        const validation = await validateEndpoint(departmentListEndpoint, \"departments\", \"\");\n        if (validation) {\n            return {\n                data: { \"Message\": validation },\n                status: {\n                    code: 400,\n                    ok: false,\n                    text: \"Bad Request\"\n                }\n            };\n        }\n        const result = await fetchDepartmentList(departmentListEndpoint);\n        return result;\n    } else {\n        return {\n            data: { \"Message\": \"You need to enter a valid endpoint.\" },\n            status: {\n                code: 400,\n                ok: false,\n                text: \"Bad Request\"\n            }\n        };\n    }\n}\n\nprettyDepartmentList = {\n    let jsonString;\n    if (typeof departmentList === 'string') {\n        jsonString = JSON.stringify(JSON.parse(departmentList), null, 2);\n    } else {\n        jsonString = JSON.stringify(departmentList, null, 2);\n    }\n    \n    // Highlight the entire Medieval Art object\n    return jsonString.replace(\n        /(\\{[^\\}]*\"displayName\":\\s*\"Medieval Art\"[^\\}]*\\})/g, \n        '&lt;span style=\"background-color: #fff3cd; display: inline-block; width: 100%;\"&gt;$1&lt;/span&gt;'\n    );\n}    \n\nviewof prettyDepartmentListContainer = {\n    let content;\n    if (departmentList.data.Message) {\n        content = html`&lt;div class=\"alert alert-warning m-0\"&gt;${departmentList.data.Message}&lt;/div&gt;`;\n    } else {\n        content = html`&lt;pre class=\"card-body m-0\" style=\"background-color: #f8f9fa; max-height: 400px; overflow-y: auto;\"&gt;${prettyDepartmentList}&lt;/pre&gt;`;\n    }\n    \n    const badgeClass = departmentList.status.ok ? \"bg-success\" : \"bg-danger\";\n    \n    const container = html`&lt;div class=\"card\"&gt;\n        &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n            &lt;span&gt;Department list&lt;/span&gt;\n            &lt;span class=\"badge ${badgeClass}\"&gt;${departmentList.status.code} ${departmentList.status.text}&lt;/span&gt;\n        &lt;/div&gt;\n        ${content}\n    &lt;/div&gt;`;\n    return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe next step will consist of answering What is the query we need to use to search for ‘knights’ in the department of Medieval Art?\nAs we’ve seen in the documentation, we will require two parameters: q and departmentId. The first one is the search term ‘knight’, and the second one is the departmentId we got from the previous step.\nTherefore, write here the query that will retrive all the objects that contain the term ‘knight’ in the department of Medieval Art.\n\n\nCode\nviewof knightsQuery = Inputs.text({\n    label: \"Query\",\n    placeholder: \"\",\n    value: \"\",\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n});\n\nasync function fetchQuery(endpoint) {\n    try {\n        const response = await fetch(endpoint);\n        const status = {\n            code: response.status,\n            ok: response.ok,\n            text: response.statusText\n        };\n\n        if (!response.ok) {\n            throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const data = await response.json();\n        return { data, status };\n    } catch (error) {\n        return {\n            data: { \"Message\": `Error: ${error.message}` },\n            status: {\n                code: 400,\n                ok: false,\n                text: \"Bad Request\"\n            }\n        };\n    }\n}\n\nqueryResult = {\n    if (knightsQuery) {\n        const validation = await validateEndpoint(knightsQuery, \"search\", \"q=knight&departmentId=17\");\n        if (validation) {\n            return {\n                data: { \"Message\": validation },\n                status: {\n                    code: 400,\n                    ok: false,\n                    text: \"Bad Request\"\n                }\n            };\n        }\n        const result = await fetchQuery(knightsQuery);\n        return result;\n    } else {\n        return {\n            data: { \"Message\": \"You need to enter a valid endpoint.\" },\n            status: {\n                code: 400,\n                ok: false,\n                text: \"Bad Request\"\n            }\n        };\n    }\n}\n\nprettyQueryResult = {\n    let jsonString;\n    if (typeof queryResult === 'string') {\n        jsonString = JSON.stringify(JSON.parse(queryResult), null, 2);\n    } else {\n        jsonString = JSON.stringify(queryResult, null, 2);\n    }\n    return jsonString;\n}\n\nviewof prettyQueryResultContainer = {\n    let content;\n    if (queryResult.data.Message) {\n        content = html`&lt;div class=\"alert alert-warning m-0\"&gt;${queryResult.data.Message}&lt;/div&gt;`;\n    } else {\n        content = html`&lt;pre class=\"card-body m-0\" style=\"background-color: #f8f9fa; max-height: 400px; overflow-y: auto;\"&gt;${prettyQueryResult}&lt;/pre&gt;`;\n    }\n    \n    const badgeClass = queryResult.status.ok ? \"bg-success\" : \"bg-danger\";\n    \n    const container = html`&lt;div class=\"card\"&gt;\n        &lt;div class=\"card-header d-flex justify-content-between align-items-center\"&gt;\n            &lt;span&gt;Query result&lt;/span&gt;\n            &lt;span class=\"badge ${badgeClass}\"&gt;${queryResult.status.code} ${queryResult.status.text}&lt;/span&gt;\n        &lt;/div&gt;\n        ${content}\n    &lt;/div&gt;`;\n    return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHaving the query result, the only thing left to do is to get the specific information we need. In this case, you can see that the answer is in the same response under the key total. Just to validate that we have the same answer, write in the next cell the total number of objects that contain the term ‘knight’ in the department of Medieval Art.\n\n\nCode\nviewof knightsTotal = Inputs.number({\n    label: \"Total number of knights\",\n    placeholder: \"\",\n    value: 0,\n    attributes: {\n        class: \"form-control mb-3\"\n    }\n});\n\nviewof validationResult = {\n    const container = html`&lt;div&gt;&lt;/div&gt;`;\n    \n    if (!queryResult.status.ok || queryResult.data.Message) {\n        if (knightsTotal !== 0) {  // Only show warning if user has entered a number\n            container.innerHTML = `\n                &lt;div class=\"alert alert-warning\"&gt;\n                    Please enter a valid query first before submitting your answer!\n                &lt;/div&gt;`;\n        }\n    } else if (queryResult.data.total !== undefined) {\n        if (knightsTotal === queryResult.data.total) {\n            container.innerHTML = `\n                &lt;div class=\"alert alert-success\"&gt;\n                    Correct! There are ${queryResult.data.total} objects that contain the term 'knight' in the Medieval Art department.\n                &lt;/div&gt;`;\n        } else {\n            container.innerHTML = `\n                &lt;div class=\"alert alert-danger\"&gt;\n                    That's not correct. Try again!\n                &lt;/div&gt;`;\n        }\n    }\n    \n    return container;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGreat! Now you know the basics stepts to get data from an API. In the next chapter, we will show you how to get data that can be tabulated and analyzed.",
    "crumbs": [
      "Interacting with APIs",
      "Exercise: Calling Data"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Unlocking Data",
    "section": "",
    "text": "A presentation will be given here…",
    "crumbs": [
      "Introduction"
    ]
  },
  {
    "objectID": "index.html#a-gentle-introduction-to-apis",
    "href": "index.html#a-gentle-introduction-to-apis",
    "title": "Unlocking Data",
    "section": "",
    "text": "A presentation will be given here…",
    "crumbs": [
      "Introduction"
    ]
  }
]