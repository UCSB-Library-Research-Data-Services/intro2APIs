{
  "hash": "705e09767cc03bfe9bb6c913f2133150",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Collecting Data for Analysis\"\nexecute:\n    echo: true\n    message: false\nformat:\n    html:\n        code-fold: false\nlightbox: true\n---\n\n\n\n\nDuring the previous chapters, we learned how to interact with APIs to retrieve data. We also practiced retrieving the total number of objects that contain a specific term in a particular department of the Metropolitan Museum of Art.\n\nIn this chapter, we will take the next step: collecting and analyzing data using the Metropolitan Museum of Art API. Specifically, we will explore the question: **What thematic areas can we identify from the terms associated with objects in the Medieval Art collection?**\n\nBy analyzing how pairs of terms co-occur, we aim to uncover thematic areas and explore whether these topics reveal insights about Medieval Art — at least from the perspective of the Metropolitan Museum of Art's metadata.\n\nThis chapter will show how data-driven analysis can provide a fresh lens to interpret cultural artifacts and examine the stories embedded within museum collections.\n\n## What data to collect?\n\nBefore starting to collect data, we need to explore what data is available and how it can help answer our research question. The first step is to examine a random object from the Medieval Art collection to identify useful fields for our analysis.\n\nAs a reminder, we can use the endpoint `https://collectionapi.metmuseum.org/public/collection/v1/objects?departmentIds=17` to retrieve a list of object IDs from the Medieval Art collection. Simply paste the full endpoint into your browser to see a response like this:\n\n```json\n\n{\n     \"total\": 7136,\n     \"objectIDs\": [\n        32830, 32831, 32832, 32833, 32834,\n        32835, 32836, 32837, 32838, 32839,\n        // ... many more IDs ...\n        818469, 818574, 831188\n        ]\n}\n\n```\n\nOnce we have an object ID, we can use it to get detailed information about that object by appending the ID to the endpoint `https://collectionapi.metmuseum.org/public/collection/v1/objects/{objectID}`. For example, the object with ID 32830 gives the following detailed response:\n\n```json\n{\n  \"objectID\": 32830,\n  \"isHighlight\": false,\n  \"accessionNumber\": \"23.21.2\",\n  \"accessionYear\": \"1923\",\n  \"isPublicDomain\": true,\n  \"primaryImage\": \"https://images.metmuseum.org/CRDImages/md/original/DP164978.jpg\",\n  \"primaryImageSmall\": \"https://images.metmuseum.org/CRDImages/md/web-large/DP164978.jpg\",\n  \"additionalImages\": [\n    \"https://images.metmuseum.org/CRDImages/md/original/DP164979.jpg\"\n  ],\n  \"constituents\": null,\n  \"department\": \"Medieval Art\",\n  \"objectName\": \"Manuscript cutting from a Dominican antiphonary\",\n  \"title\": \"Initial P with the Martyrdom of Saint Peter Martyr\",\n  \"culture\": \"Italian\",\n  \"period\": \"\",\n  \"dynasty\": \"\",\n  \"reign\": \"\",\n  \"portfolio\": \"\",\n  \"artistRole\": \"\",\n  \"artistPrefix\": \"\",\n  \"artistDisplayName\": \"\",\n  \"artistDisplayBio\": \"\",\n  \"artistSuffix\": \"\",\n  \"artistAlphaSort\": \"\",\n  \"artistNationality\": \"\",\n  \"artistBeginDate\": \"\",\n  \"artistEndDate\": \"\",\n  \"artistGender\": \"\",\n  \"artistWikidata_URL\": \"\",\n  \"artistULAN_URL\": \"\",\n  \"objectDate\": \"second half 13th century\",\n  \"objectBeginDate\": 1350,\n  \"objectEndDate\": 1400,\n  \"medium\": \"Tempera and ink on parchment\",\n  \"dimensions\": \"3 1/8 x 2 13/16 in. (7.9 x 7.1 cm)\",\n  \"measurements\": null,\n  \"creditLine\": \"Gift of Bashford Dean, 1923\",\n  \"geographyType\": \"Made in\",\n  \"city\": \"Bologna\",\n  \"state\": \"\",\n  \"county\": \"\",\n  \"country\": \"Italy\",\n  \"region\": \"\",\n  \"subregion\": \"\",\n  \"locale\": \"\",\n  \"locus\": \"\",\n  \"excavation\": \"\",\n  \"river\": \"\",\n  \"classification\": \"Manuscripts and Illuminations\",\n  \"rightsAndReproduction\": \"\",\n  \"linkResource\": \"\",\n  \"metadataDate\": \"2024-10-03T04:53:53.567Z\",\n  \"repository\": \"Metropolitan Museum of Art, New York, NY\",\n  \"objectURL\": \"https://www.metmuseum.org/art/collection/search/32830\",\n  \"tags\": [\n    {\n      \"term\": \"Saint Peter\",\n      \"AAT_URL\": \"http://vocab.getty.edu/page/ia/901000056\",\n      \"Wikidata_URL\": \"https://www.wikidata.org/wiki/Q33923\"\n    },\n    {\n      \"term\": \"Men\",\n      \"AAT_URL\": \"http://vocab.getty.edu/page/aat/300025928\",\n      \"Wikidata_URL\": \"https://www.wikidata.org/wiki/Q8441\"\n    }\n  ],\n  \"objectWikidata_URL\": \"\",\n  \"isTimelineWork\": true,\n  \"GalleryNumber\": \"\"\n}\n\n```\n\nBy exploring the object data, we can identify several fields of interest, such as title, objectName, medium, culture, objectDate, and tags. For our analysis, we will focus on the tags field, which provides a list of terms associated with the object.\n\nThe tags field is particularly valuable because it uses controlled vocabularies like the Art and Architecture Thesaurus (AAT) and Wikidata, ensuring consistency across the dataset. These terms capture key themes and concepts, making them ideal for analyzing thematic areas in Medieval Art.\n\n## Collecting data\n\nNow that we have identified the tags field as the focus of our analysis, we can start collecting data. To do this, we need to extract the specific information we need and store it in a format suitable for analysis.\n\nTypically, this involves isolating the necessary information and storing it in a structured format like CSV (Comma-Separated Values). For our purpose, the CSV file will have two columns: `objectID` and `tags`. An example of the data is shown below:\n\n```csv\nobjectID,terms\n462990,\"['Entombment', 'Christ', 'Virgin Mary']\"\n462991,['Women']\n462992,\"['Men', 'Cross', 'Christ']\"\n462994,['Men']\n462995,['Men']\n462997,\"['Cross', 'Christ']\"\n462998,\"['Animals', 'Birds']\"\n463015,\"['Men', 'Portraits']\"\n463023,['Deer']\n463024,['Eagles']\n463032,\"['Entombment', 'Christ']\"\n463036,\"['Illness', 'Men', 'Women']\"\n463037,\"['Kings', 'Women', 'David', 'Eve']\"\n463039,\"['Kings', 'Baptismal Fonts', 'Saints']\"\n463040,\"['Infants', 'Women', 'Baptismal Fonts']\"\n463052,['Deer']\n463081,\"['Animals', 'Cross']\"\n463083,['Human Figures']\n463084,\"['Human Figures', 'Angels']\"\n```\n\nThis data was collected from the first 100 objects in the Medieval Art collection. It's important to note that not all objects have tags, and some only have one term. Exploring the data is crucial to understanding its completeness and whether it can answer our research question.\n\nEven with incomplete data, we can still identify thematic areas. For example, we can extract term pairs that co-occur within the same object. For object ID 462990, the terms `Entombment`, `Christ`, and `Virgin Mary` co-occur, which can be represented like this:\n\n```csv\nSource,Target\nEntombment,Christ\nEntombment,Virgin Mary\nChrist,Virgin Mary\n```\n\nWhen we notice that some pairs repeat across different objects, we can add weights to these pairs. For example, the pair Men and Cross appears in both 462992 and 462997, giving it a weight of 2. The table becomes:\n\n```csv\nSource,Target,Weight\nEntombment,Christ,1\nEntombment,Virgin Mary,1\nChrist,Virgin Mary,1\nMen,Cross,2\nMen,Christ,1\nCross,Christ,1\n```\n\nUsing this small sample, we can already start drafting a simple network graph to visualize these relationships.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(igraph)\n\nedges <- data.frame(\n  Source = c(\n  \"Entombment\", \"Entombment\", \"Christ\", \"Men\", \"Men\", \"Cross\", \n  \"Animals\", \"Men\", \"Illness\", \"Illness\", \"Men\", \"Kings\", \n  \"Kings\", \"Kings\", \"Women\", \"Women\", \"David\"\n),\n  Target = c(\n  \"Christ\", \"Virgin Mary\", \"Virgin Mary\", \"Cross\", \"Christ\", \"Christ\", \n  \"Birds\", \"Portraits\", \"Men\", \"Women\", \"Women\", \"Women\", \n  \"David\", \"Eve\", \"David\", \"Eve\", \"Eve\"\n),\n  Weight = c(\n  2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1\n)\n\n)\n\nnetwork <- graph_from_data_frame(edges, directed = FALSE)\n\nplot(\n  network,\n  vertex.size = 30,\n  vertex.label.cex = 0.8,\n  edge.width = E(network)$Weight * 2,\n  edge.color = \"gray50\",\n  vertex.color = \"lightblue\",\n  main = \"Network Graph\"\n)\n```\n\n::: {.cell-output-display}\n![](collecting-data-for-analysis_files/figure-html/unnamed-chunk-1-1.png){width=960}\n:::\n:::\n\n\n\n\nThis simple network graph provides a glimpse of the relationships between terms. For instance, we can see how the network is highly centered around the term \"Men,\" which connects with other groups associated with \"Christ.\" In contrast, \"Women\" is part of a smaller group tied to terms like \"Eve,\" \"David,\" and \"Kings.\" While this is just a small sample, it demonstrates how network analysis can reveal thematic patterns.\n\nWith this proof of concept, we’re ready to scale up to the entire Medieval Art collection. The complete data includes term pairs from 3695 objects, resulting in 1725 unique pairs. The dataset is stored in a CSV file, which can be accessed here: [Medieval Art Data - Terms Network](../data/terms_collection17.csv). Below is a preview of the first 20 rows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nterms_collection <- read.csv(\"../data/terms_collection17.csv\")\nhead(terms_collection, 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n                  Source                     Target Weight\n1               Achilles                   Centaurs      1\n2               Achilles                     Horses      1\n3               Achilles                        Men      1\n4               Achilles                      Tents      1\n5               Achilles                 Trojan War      1\n6                   Adam                     Angels      1\n7                   Adam                     Christ      2\n8                   Adam                Crucifixion      2\n9                   Adam                        Eve      6\n10                  Adam                   Nativity      1\n11                  Adam                Virgin Mary      1\n12                  Adam                    Working      1\n13 Adoration of the Magi Adoration of the Shepherds      2\n14 Adoration of the Magi                     Angels      4\n15 Adoration of the Magi               Annunciation      5\n16 Adoration of the Magi                       Beds      1\n17 Adoration of the Magi                     Christ      8\n18 Adoration of the Magi                Crucifixion      6\n19 Adoration of the Magi                       Dogs      1\n20 Adoration of the Magi                      Jesus      6\n```\n\n\n:::\n:::\n\n\n\n\n\nIn the next chapter, we’ll use this full dataset to build a comprehensive network graph, analyze its structure, and uncover thematic clusters that provide deeper insights into the Medieval Art collection.\n\n::: {.callout-tip collapse=\"true\"}\n## A Note About Automation\nTo collect the data for this project, we used a Python script to automate the process. This ensured accuracy and efficiency when processing thousands of objects in the Medieval Art collection. The script performs the following steps:\n\n1. Retrieves object IDs from the API.\n2. Fetches tags for each object.\n3. Generates term pairs and calculates weights.\n4. Saves the results in a CSV file for analysis.\n\nHere’s the code used for this process. If you’re familiar with Python, you can experiment with it to collect data from other departments or customize it to fit your needs:\n\n```python\n\nimport httpx\nimport time\nimport json\nfrom itertools import combinations\nimport pandas as pd\n\n\ndef get_api_data(endpoint: str, params: dict | None = None) -> dict:\n    \"\"\"\n    Get data from the API.\n\n    Parameters:\n        endpoint (str): The endpoint to get data from.\n        params (dict, optional): The parameters to pass to the endpoint.\n\n    Returns:\n        dict: The data from the API in JSON format.\n\n    Raises:\n        Exception: If the HTTP request fails or JSON decoding fails.\n    \"\"\"\n    params = params or {}\n    \n    try:\n        response = httpx.get(endpoint, params=params)\n        response.raise_for_status()\n        return response.json()\n    except httpx.HTTPStatusError as e:\n        raise Exception(f\"HTTP request failed: {e}\")\n    except json.JSONDecodeError as e:\n        raise Exception(f\"Failed to decode JSON response: {e}\")\n\n    \ndef get_terms_from_endpoint(endpoint: str, objectID: str, return_full_list: bool = False) -> list[str]:\n    \"\"\"\n    Get terms from an endpoint.\n\n    Parameters:\n        endpoint (str): Base endpoint URL\n        objectID (str): Object ID to append to endpoint\n        return_full_list (bool): If True, returns full list of terms; if False, returns pairs\n\n    Returns:\n        list[str] | list[dict[str, str]]: List of terms or list of term pairs\n    \"\"\"\n    try:\n        endpoint = f\"{endpoint}/{objectID}\"\n        data = get_api_data(endpoint)\n        data = data[\"tags\"]\n        terms = [tag[\"term\"] for tag in data]\n\n        if return_full_list:\n            return terms\n        elif len(terms) > 1:\n            pairs = list(combinations(terms, 2))\n            return [{\"Source\": pair[0], \"Target\": pair[1]} for pair in pairs]\n        \n    except KeyError as ke:\n        print(f\"KeyError for objectID {objectID}: {ke}\") \n        raise\n    except TypeError as te:\n        print(f\"TypeError for objectID {objectID}: {te}\")\n        raise\n\ndef get_terms_from_API(\n        collection_endpoint: str, \n        collection_params: dict | None = None, \n        object_endpoint: str | None = None,\n        report: bool = False, \n        report_file: str = \"report.txt\", \n        save_file: str = \"terms.json\",\n        save_csv: str = \"terms.csv\",\n        verbose: bool = False,\n        return_full_list: bool = False,\n        limit: int = None) -> tuple[list[str | dict[str, str]], int]:\n    \"\"\"\n    Get terms from the API.\n\n    Parameters:\n        collection_endpoint (str): The endpoint for the collection of objects.\n        collection_params (dict, optional): Parameters for the collection endpoint.\n        object_endpoint (str): The endpoint for individual objects.\n        report (bool): Whether to generate a report.\n        report_file (str): Path to save the report.\n        save_file (str): Path to save terms as JSON.\n        save_csv (str): Path to save terms as CSV.\n        verbose (bool): Whether to print progress.\n        return_full_list (bool): Whether to return full list of terms.\n        limit (int, optional): Maximum number of objects to process.\n\n    Returns:\n        tuple[list, int]: List of terms or term pairs, and count of failed requests.\n    \"\"\"\n\n    collection_params = collection_params or {}\n\n    if not object_endpoint:\n        raise ValueError(\"object_endpoint must be provided\")\n    \n    objectIDs = get_api_data(collection_endpoint, collection_params).get(\"objectIDs\")\n    if not objectIDs:\n        return [], 0\n\n    if limit:\n        objectIDs = objectIDs[:limit]\n    \n    terms = []\n    none_count = 0\n\n    for objectID in objectIDs:\n        time.sleep(0.5) # Consider to implement a rate limiter\n        try:\n            object_terms = get_terms_from_endpoint(\n                object_endpoint, \n                str(objectID), \n                return_full_list\n            )\n            \n            if object_terms:\n                terms.extend(object_terms)\n                if verbose:\n                    print(f\"{objectID} terms: {object_terms}\")\n        except Exception as e:\n            if verbose:\n                print(f\"Failed to process objectID {objectID}: {e}\")\n            none_count += 1\n\n    if save_csv and not return_full_list:\n        df = pd.DataFrame(terms)\n        if not df.empty:\n            df = df.groupby([\"Source\", \"Target\"]).size().reset_index(name=\"Weight\")\n            df.to_csv(save_csv, index=False)\n\n    if save_file:\n        with open(save_file, \"w\") as f:\n            json.dump(terms, f)\n\n    if report:\n        report_text = (\n            f\"Total objects: {len(objectIDs)}\\n\"\n            f\"Total terms: {len(terms)}\\n\"\n            f\"Failed requests: {none_count}\"\n        )\n        with open(report_file, \"w\") as f:\n            f.write(report_text)\n\n    return terms, none_count\n```\n\n:::\n",
    "supporting": [
      "collecting-data-for-analysis_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}